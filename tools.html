<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>msmhelper.tools API documentation</title>
<meta name="description" content="Set of helpful functions â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#282c34;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px;margin:1em 0;padding:1ex}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver;margin-top:10px;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em;-webkit-border-radius:6px;-moz-border-radius:6px;border-radius:6px}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS_CHTML'></script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>msmhelper.tools</code></h1>
</header>
<section id="section-intro">
<p>Set of helpful functions.</p>
<p>BSD 3-Clause License
Copyright (c) 2019-2020, Daniel Nagel
All rights reserved.</p>
<h2 id="todo">Todo</h2>
<ul>
<li>Correct border effects of running mean</li>
</ul>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;Set of helpful functions.

BSD 3-Clause License
Copyright (c) 2019-2020, Daniel Nagel
All rights reserved.

TODO:
    - Correct border effects of running mean

&#34;&#34;&#34;
import datetime
import getpass  # noqa: SC100 # get user name with getpass.getuser()
import os
import platform  # get pc name with platform.node()
import sys

import numba
import numpy as np

import __main__ as main
from msmhelper.statetraj import StateTraj


def shift_data(array, val_old, val_new, dtype=np.int64):
    &#34;&#34;&#34;Shift integer array (data) from old to new values.

    &gt; **CAUTION:**
    &gt; The values of `val_old`, `val_new` and `data` needs to be integers.

    The basic function is based on Ashwini_Chaudhary solution:
    https://stackoverflow.com/a/29408060

    Parameters
    ----------
    array : StateTraj or ndarray or list or list of ndarrays
        1D data or a list of data.

    val_old : ndarray or list
        Values in data which should be replaced. All values needs to be within
        the range of `[data.min(), data.max()]`

    val_new : ndarray or list
        Values which will be used instead of old ones.

    dtype : data-type, optional
        The desired data-type. Needs to be of type unsigned integer.

    Returns
    -------
    array : ndarray
        Shifted data in same shape as input.

    &#34;&#34;&#34;
    # check data-type
    if not np.issubdtype(dtype, np.integer):
        raise TypeError(&#39;An unsigned integer type is needed.&#39;)

    # flatten data
    array, shape_kwargs = _flatten_data(array)

    # offset data and val_old to allow negative values
    offset = np.min([np.min(array), np.min(val_new)])

    # convert to np.array
    val_old = (np.asarray(val_old) - offset).astype(dtype)
    val_new = (np.asarray(val_new) - offset).astype(dtype)

    # convert data and shift
    array = (array - offset).astype(dtype)

    # shift data
    conv = np.arange(array.max() + 1, dtype=dtype)
    conv[val_old] = val_new
    array = conv[array]

    # shift data back
    array = array.astype(np.int32) + offset

    # reshape and return
    return _unflatten_data(array, shape_kwargs)


def rename_by_population(trajs, return_permutation=False):
    r&#34;&#34;&#34;Rename states sorted by their population starting from 1.

    Parameters
    ----------
    trajs : list or ndarray or list of ndarrays
        State trajectory or list of state trajectories.

    return_permutation : bool
        Return additionaly the permutation to achieve performed renaming.
        Default is False.

    Returns
    -------
    trajs : ndarray
        Renamed data.

    permutation : ndarray
        Permutation going from old to new state nameing. So the `i`th state
        of the new naming corresponds to the old state `permutation[i-1]`.

    &#34;&#34;&#34;
    # get unique states with population
    states, pop = unique(trajs, return_counts=True)

    # get decreasing order
    idx_sort = np.argsort(pop)[::-1]
    states = states[idx_sort]

    # rename states
    trajs_renamed = shift_data(
        trajs,
        val_old=states,
        val_new=np.arange(len(states)) + 1,
    )
    if return_permutation:
        return trajs_renamed, states
    return trajs_renamed


def rename_by_index(trajs, return_permutation=False):
    r&#34;&#34;&#34;Rename states sorted by their numerical values starting from 0.

    Parameters
    ----------
    trajs : list or ndarray or list of ndarrays
        State trajectory or list of state trajectories.

    return_permutation : bool
        Return additionaly the permutation to achieve performed renaming.
        Default is False.

    Returns
    -------
    trajs : ndarray
        Renamed data.

    permutation : ndarray
        Permutation going from old to new state nameing. So the `i`th state
        of the new naming corresponds to the old state `permutation[i-1]`.

    &#34;&#34;&#34;
    # get unique states
    states = unique(trajs)

    # rename states
    trajs_renamed = shift_data(
        trajs,
        val_old=states,
        val_new=np.arange(len(states)),
    )
    if return_permutation:
        return trajs_renamed, states
    return trajs_renamed


def unique(trajs, **kwargs):
    r&#34;&#34;&#34;Apply numpy.unique to traj.

    Parameters
    ----------
    trajs : list or ndarray or list of ndarrays
        State trajectory or list of state trajectories.

    kwargs
        Arguments of [numpy.unique()](https://docs.scipy.org/doc/numpy/reference/generated.numpy.unique.html)

    Returns
    -------
    unique
        Array containing all states, see numpy for more details.

    &#34;&#34;&#34;
    # flatten data
    trajs, _ = _flatten_data(trajs)

    # get unique states with population
    return np.unique(trajs, **kwargs)


def runningmean(array, window):
    r&#34;&#34;&#34;Compute centered running average with given window size.

    This function returns the centered based running average of the given
    data. The output of this function is of the same length as the input,
    by assuming that the given data is zero before and after the given
    series. Hence, there are border affects which are not corrected.

    &gt; **CAUTION:**
    &gt; If the given window is even (not symmetric) it will be shifted towards
    &gt; the beginning of the current value. So for `window=4`, it will consider
    &gt; the current position \(i\), the two to the left \(i-2\) and \(i-1\) and
    &gt; one to the right \(i+1\).

    Function is taken from lapis:
    https://stackoverflow.com/questions/13728392/moving-average-or-running-mean

    Parameters
    ----------
    array : ndarray
        One dimensional numpy array.

    window : int
        Integer which specifies window-width.

    Returns
    -------
    array_rmean : ndarray
        Data which is time-averaged over the specified window.

    &#34;&#34;&#34;
    # Calculate running mean
    return np.convolve(
        array,
        np.ones(window) / window,
        mode=&#39;same&#39;,
    )


def swapcols(array, indicesold, indicesnew):
    r&#34;&#34;&#34;Interchange cols of an ndarray.

    This method swaps the specified columns.
    .. todo:: Optimize memory usage

    Parameters
    ----------
    array : ndarray
        2D numpy array.
    indicesold : integer or ndarray
        1D array of indices.
    indicesnew : integer or ndarray
        1D array of new indices

    Returns
    -------
    array_swapped : ndarray
        2D numpy array with swappend columns.

    &#34;&#34;&#34;
    # cast to 1d arrays
    indicesnew = _asindex(indicesnew)
    indicesold = _asindex(indicesold)

    if len(indicesnew) != len(indicesold):
        raise ValueError(&#39;Indices needs to be of same shape.&#39;)

    # cast data
    array = np.asarray(array)

    if np.all(indicesnew == indicesold):
        return array

    # fails for large data sets
    # noqa: E800 # array.T[indicesold] = array.T[indicesnew]
    array_swapped = np.copy(array)
    array_swapped.T[indicesold] = array.T[indicesnew]

    return array_swapped


def get_runtime_user_information():
    r&#34;&#34;&#34;Get user runtime information.

    &gt; **CAUTION:**
    &gt; For python 3.5 or lower the date is not formatted and contains
    &gt; microscends.

    Returns
    -------
    RUI : dict
        Holding username in &#39;user&#39;, pc name in &#39;pc&#39;, date of execution &#39;date&#39;,
        path of execution &#39;script_dir&#39; and name of execution main file
        &#39;script_name&#39;. In case of interactive usage, script_name is &#39;console&#39;.

    &#34;&#34;&#34;
    try:
        script_dir, script_name = os.path.split(
            os.path.abspath(main.__file__),  # noqa: WPS609
        )
    except AttributeError:  # pragma: no cover
        script_dir, script_name = &#39;&#39;, &#39;console&#39;

    # get time without microseconds
    date = datetime.datetime.now()
    if sys.version_info &gt;= (3, 6):
        date = date.isoformat(sep=&#39; &#39;, timespec=&#39;seconds&#39;)

    return {
        &#39;user&#39;: getpass.getuser(),
        &#39;pc&#39;: platform.node(),
        &#39;date&#39;: date,
        &#39;script_dir&#39;: script_dir,
        &#39;script_name&#39;: script_name,
    }


def _asindex(idx):
    &#34;&#34;&#34;Cast to 1d integer ndarray.&#34;&#34;&#34;
    idx = np.atleast_1d(idx).astype(np.int64)
    if len(idx.shape) &gt; 1:
        raise ValueError(&#39;Wrong dimensionality of indices.&#39;)
    return idx


def format_state_traj(trajs):
    &#34;&#34;&#34;Convert state trajectory to list of ndarrays.

    Parameters
    ----------
    trajs : list or ndarray or list of ndarray
        State trajectory/trajectories. The states should start from zero and
        need to be integers.

    Returns
    -------
    trajs : list of ndarray
        Return list of ndarrays of integers.

    &#34;&#34;&#34;
    # list or tuple
    if isinstance(trajs, (tuple, list)):
        # list of integers
        if all((np.issubdtype(type(state), np.integer) for state in trajs)):
            trajs = [np.array(trajs)]
        # list of lists
        elif all((isinstance(traj, list) for traj in trajs)):
            trajs = [np.array(traj) for traj in trajs]
    # ndarray
    if isinstance(trajs, np.ndarray):
        if len(trajs.shape) == 1:
            trajs = [trajs]
        elif len(trajs.shape) == 2:
            trajs = list(trajs)

    # check for integers
    _check_state_traj(trajs)

    return trajs


def _check_state_traj(trajs):
    &#34;&#34;&#34;Check if state trajectory is correct formatted.&#34;&#34;&#34;
    # check for integers
    if isinstance(trajs, StateTraj):
        return True

    for traj in trajs:
        if not isinstance(traj, np.ndarray):
            raise TypeError(
                &#39;Trajs need to be np.ndarray but are {0}&#39;.format(type(traj)),
            )
        if not np.issubdtype(traj.dtype, np.integer):
            raise TypeError(
                &#39;States needs to be integers but are {0}&#39;.format(traj.dtype),
            )
    return True


def _flatten_data(array):
    &#34;&#34;&#34;Flatten data to 1D ndarray.

    This method flattens ndarrays, list of ndarrays to a 1D ndarray. This can
    be undone with _unflatten_data().

    Parameters
    ----------
    array : list or ndarray or list of ndarrays
        1D data or a list of data.

    Returns
    -------
    data : ndarray
        Flattened data.

    kwargs : dict
        Dictionary with information to restore shape.

    &#34;&#34;&#34;
    kwargs = {}

    # flatten data
    if isinstance(array, (tuple, list)):
        # list of ndarrays, lists or tuples
        if all((isinstance(row, (np.ndarray, tuple, list)) for row in array)):
            # get shape and flatten
            kwargs[&#39;limits&#39;] = np.cumsum([len(row) for row in array])
            array = np.concatenate(array)
        # list of numbers
        else:
            array = np.asarray(array)
    elif isinstance(array, np.ndarray):
        # get shape and flatten
        kwargs[&#39;data_shape&#39;] = array.shape
        array = array.flatten()

    return array, kwargs


def _unflatten_data(array, kwargs):
    &#34;&#34;&#34;Unflatten data to original structure.

    This method undoes _flatten_data().

    Parameters
    ----------
    array : ndarray
        Flattened data.

    kwargs : dict
        Dictionary with information to restore shape. Provided by
        _flatten_data().

    Returns
    -------
    array : ndarray, list, list of ndarrays
        Data with restored shape.

    &#34;&#34;&#34;
    # parse kwargs
    data_shape = kwargs.get(&#39;data_shape&#39;)
    limits = kwargs.get(&#39;limits&#39;)

    # reshape
    if data_shape is not None:
        array = array.reshape(data_shape)
    elif limits is not None:
        array = np.split(array, limits)[:-1]

    return array


@numba.njit
def matrix_power(matrix, power):
    &#34;&#34;&#34;Calculate matrix power with np.linalg.matrix_power.

    Same as numpy function, except only for float matrices. See
    [np.linalg.matrix_power](https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.matrix_power.html).

    Parameters
    ----------
    matrix : ndarray
        2d matrix of type float.

    power : int, float
        Power of matrix.

    Returns
    -------
    matpow : ndarray
        Matrix power.

    &#34;&#34;&#34;
    return np.linalg.matrix_power(matrix, power)


@numba.njit
def find_first(search_val, array):
    &#34;&#34;&#34;Return first occurance of item in array.&#34;&#34;&#34;
    for idx, idx_val in enumerate(array):
        if search_val == idx_val:
            return idx
    return -1</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="msmhelper.tools.find_first"><code class="name flex">
<span>def <span class="ident">find_first</span></span>(<span>search_val, array)</span>
</code></dt>
<dd>
<div class="desc"><p>Return first occurance of item in array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.njit
def find_first(search_val, array):
    &#34;&#34;&#34;Return first occurance of item in array.&#34;&#34;&#34;
    for idx, idx_val in enumerate(array):
        if search_val == idx_val:
            return idx
    return -1</code></pre>
</details>
</dd>
<dt id="msmhelper.tools.format_state_traj"><code class="name flex">
<span>def <span class="ident">format_state_traj</span></span>(<span>trajs)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert state trajectory to list of ndarrays.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>trajs</code></strong> :&ensp;<code>list</code> or <code>ndarray</code> or <code>list</code> of <code>ndarray</code></dt>
<dd>State trajectory/trajectories. The states should start from zero and
need to be integers.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>trajs</code></strong> :&ensp;<code>list</code> of <code>ndarray</code></dt>
<dd>Return list of ndarrays of integers.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_state_traj(trajs):
    &#34;&#34;&#34;Convert state trajectory to list of ndarrays.

    Parameters
    ----------
    trajs : list or ndarray or list of ndarray
        State trajectory/trajectories. The states should start from zero and
        need to be integers.

    Returns
    -------
    trajs : list of ndarray
        Return list of ndarrays of integers.

    &#34;&#34;&#34;
    # list or tuple
    if isinstance(trajs, (tuple, list)):
        # list of integers
        if all((np.issubdtype(type(state), np.integer) for state in trajs)):
            trajs = [np.array(trajs)]
        # list of lists
        elif all((isinstance(traj, list) for traj in trajs)):
            trajs = [np.array(traj) for traj in trajs]
    # ndarray
    if isinstance(trajs, np.ndarray):
        if len(trajs.shape) == 1:
            trajs = [trajs]
        elif len(trajs.shape) == 2:
            trajs = list(trajs)

    # check for integers
    _check_state_traj(trajs)

    return trajs</code></pre>
</details>
</dd>
<dt id="msmhelper.tools.get_runtime_user_information"><code class="name flex">
<span>def <span class="ident">get_runtime_user_information</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Get user runtime information.</p>
<blockquote>
<p><strong>CAUTION:</strong>
For python 3.5 or lower the date is not formatted and contains
microscends.</p>
</blockquote>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>RUI</code></strong> :&ensp;<code>dict</code></dt>
<dd>Holding username in 'user', pc name in 'pc', date of execution 'date',
path of execution 'script_dir' and name of execution main file
'script_name'. In case of interactive usage, script_name is 'console'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_runtime_user_information():
    r&#34;&#34;&#34;Get user runtime information.

    &gt; **CAUTION:**
    &gt; For python 3.5 or lower the date is not formatted and contains
    &gt; microscends.

    Returns
    -------
    RUI : dict
        Holding username in &#39;user&#39;, pc name in &#39;pc&#39;, date of execution &#39;date&#39;,
        path of execution &#39;script_dir&#39; and name of execution main file
        &#39;script_name&#39;. In case of interactive usage, script_name is &#39;console&#39;.

    &#34;&#34;&#34;
    try:
        script_dir, script_name = os.path.split(
            os.path.abspath(main.__file__),  # noqa: WPS609
        )
    except AttributeError:  # pragma: no cover
        script_dir, script_name = &#39;&#39;, &#39;console&#39;

    # get time without microseconds
    date = datetime.datetime.now()
    if sys.version_info &gt;= (3, 6):
        date = date.isoformat(sep=&#39; &#39;, timespec=&#39;seconds&#39;)

    return {
        &#39;user&#39;: getpass.getuser(),
        &#39;pc&#39;: platform.node(),
        &#39;date&#39;: date,
        &#39;script_dir&#39;: script_dir,
        &#39;script_name&#39;: script_name,
    }</code></pre>
</details>
</dd>
<dt id="msmhelper.tools.matrix_power"><code class="name flex">
<span>def <span class="ident">matrix_power</span></span>(<span>matrix, power)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate matrix power with np.linalg.matrix_power.</p>
<p>Same as numpy function, except only for float matrices. See
<a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.matrix_power.html">np.linalg.matrix_power</a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>matrix</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>2d matrix of type float.</dd>
<dt><strong><code>power</code></strong> :&ensp;<code>int, float</code></dt>
<dd>Power of matrix.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>matpow</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Matrix power.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@numba.njit
def matrix_power(matrix, power):
    &#34;&#34;&#34;Calculate matrix power with np.linalg.matrix_power.

    Same as numpy function, except only for float matrices. See
    [np.linalg.matrix_power](https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.matrix_power.html).

    Parameters
    ----------
    matrix : ndarray
        2d matrix of type float.

    power : int, float
        Power of matrix.

    Returns
    -------
    matpow : ndarray
        Matrix power.

    &#34;&#34;&#34;
    return np.linalg.matrix_power(matrix, power)</code></pre>
</details>
</dd>
<dt id="msmhelper.tools.rename_by_index"><code class="name flex">
<span>def <span class="ident">rename_by_index</span></span>(<span>trajs, return_permutation=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename states sorted by their numerical values starting from 0.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>trajs</code></strong> :&ensp;<code>list</code> or <code>ndarray</code> or <code>list</code> of <code>ndarrays</code></dt>
<dd>State trajectory or list of state trajectories.</dd>
<dt><strong><code>return_permutation</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return additionaly the permutation to achieve performed renaming.
Default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>trajs</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Renamed data.</dd>
<dt><strong><code>permutation</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Permutation going from old to new state nameing. So the <code>i</code>th state
of the new naming corresponds to the old state <code>permutation[i-1]</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_by_index(trajs, return_permutation=False):
    r&#34;&#34;&#34;Rename states sorted by their numerical values starting from 0.

    Parameters
    ----------
    trajs : list or ndarray or list of ndarrays
        State trajectory or list of state trajectories.

    return_permutation : bool
        Return additionaly the permutation to achieve performed renaming.
        Default is False.

    Returns
    -------
    trajs : ndarray
        Renamed data.

    permutation : ndarray
        Permutation going from old to new state nameing. So the `i`th state
        of the new naming corresponds to the old state `permutation[i-1]`.

    &#34;&#34;&#34;
    # get unique states
    states = unique(trajs)

    # rename states
    trajs_renamed = shift_data(
        trajs,
        val_old=states,
        val_new=np.arange(len(states)),
    )
    if return_permutation:
        return trajs_renamed, states
    return trajs_renamed</code></pre>
</details>
</dd>
<dt id="msmhelper.tools.rename_by_population"><code class="name flex">
<span>def <span class="ident">rename_by_population</span></span>(<span>trajs, return_permutation=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Rename states sorted by their population starting from 1.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>trajs</code></strong> :&ensp;<code>list</code> or <code>ndarray</code> or <code>list</code> of <code>ndarrays</code></dt>
<dd>State trajectory or list of state trajectories.</dd>
<dt><strong><code>return_permutation</code></strong> :&ensp;<code>bool</code></dt>
<dd>Return additionaly the permutation to achieve performed renaming.
Default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>trajs</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Renamed data.</dd>
<dt><strong><code>permutation</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Permutation going from old to new state nameing. So the <code>i</code>th state
of the new naming corresponds to the old state <code>permutation[i-1]</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rename_by_population(trajs, return_permutation=False):
    r&#34;&#34;&#34;Rename states sorted by their population starting from 1.

    Parameters
    ----------
    trajs : list or ndarray or list of ndarrays
        State trajectory or list of state trajectories.

    return_permutation : bool
        Return additionaly the permutation to achieve performed renaming.
        Default is False.

    Returns
    -------
    trajs : ndarray
        Renamed data.

    permutation : ndarray
        Permutation going from old to new state nameing. So the `i`th state
        of the new naming corresponds to the old state `permutation[i-1]`.

    &#34;&#34;&#34;
    # get unique states with population
    states, pop = unique(trajs, return_counts=True)

    # get decreasing order
    idx_sort = np.argsort(pop)[::-1]
    states = states[idx_sort]

    # rename states
    trajs_renamed = shift_data(
        trajs,
        val_old=states,
        val_new=np.arange(len(states)) + 1,
    )
    if return_permutation:
        return trajs_renamed, states
    return trajs_renamed</code></pre>
</details>
</dd>
<dt id="msmhelper.tools.runningmean"><code class="name flex">
<span>def <span class="ident">runningmean</span></span>(<span>array, window)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute centered running average with given window size.</p>
<p>This function returns the centered based running average of the given
data. The output of this function is of the same length as the input,
by assuming that the given data is zero before and after the given
series. Hence, there are border affects which are not corrected.</p>
<blockquote>
<p><strong>CAUTION:</strong>
If the given window is even (not symmetric) it will be shifted towards
the beginning of the current value. So for <code>window=4</code>, it will consider
the current position <span><span class="MathJax_Preview">i</span><script type="math/tex">i</script></span>, the two to the left <span><span class="MathJax_Preview">i-2</span><script type="math/tex">i-2</script></span> and <span><span class="MathJax_Preview">i-1</span><script type="math/tex">i-1</script></span> and
one to the right <span><span class="MathJax_Preview">i+1</span><script type="math/tex">i+1</script></span>.</p>
</blockquote>
<p>Function is taken from lapis:
<a href="https://stackoverflow.com/questions/13728392/moving-average-or-running-mean">https://stackoverflow.com/questions/13728392/moving-average-or-running-mean</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>One dimensional numpy array.</dd>
<dt><strong><code>window</code></strong> :&ensp;<code>int</code></dt>
<dd>Integer which specifies window-width.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array_rmean</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Data which is time-averaged over the specified window.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def runningmean(array, window):
    r&#34;&#34;&#34;Compute centered running average with given window size.

    This function returns the centered based running average of the given
    data. The output of this function is of the same length as the input,
    by assuming that the given data is zero before and after the given
    series. Hence, there are border affects which are not corrected.

    &gt; **CAUTION:**
    &gt; If the given window is even (not symmetric) it will be shifted towards
    &gt; the beginning of the current value. So for `window=4`, it will consider
    &gt; the current position \(i\), the two to the left \(i-2\) and \(i-1\) and
    &gt; one to the right \(i+1\).

    Function is taken from lapis:
    https://stackoverflow.com/questions/13728392/moving-average-or-running-mean

    Parameters
    ----------
    array : ndarray
        One dimensional numpy array.

    window : int
        Integer which specifies window-width.

    Returns
    -------
    array_rmean : ndarray
        Data which is time-averaged over the specified window.

    &#34;&#34;&#34;
    # Calculate running mean
    return np.convolve(
        array,
        np.ones(window) / window,
        mode=&#39;same&#39;,
    )</code></pre>
</details>
</dd>
<dt id="msmhelper.tools.shift_data"><code class="name flex">
<span>def <span class="ident">shift_data</span></span>(<span>array, val_old, val_new, dtype=numpy.int64)</span>
</code></dt>
<dd>
<div class="desc"><p>Shift integer array (data) from old to new values.</p>
<blockquote>
<p><strong>CAUTION:</strong>
The values of <code>val_old</code>, <code>val_new</code> and <code>data</code> needs to be integers.</p>
</blockquote>
<p>The basic function is based on Ashwini_Chaudhary solution:
<a href="https://stackoverflow.com/a/29408060">https://stackoverflow.com/a/29408060</a></p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>StateTraj</code> or <code>ndarray</code> or <code>list</code> or <code>list</code> of <code>ndarrays</code></dt>
<dd>1D data or a list of data.</dd>
<dt><strong><code>val_old</code></strong> :&ensp;<code>ndarray</code> or <code>list</code></dt>
<dd>Values in data which should be replaced. All values needs to be within
the range of <code>[data.min(), data.max()]</code></dd>
<dt><strong><code>val_new</code></strong> :&ensp;<code>ndarray</code> or <code>list</code></dt>
<dd>Values which will be used instead of old ones.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>data-type</code>, optional</dt>
<dd>The desired data-type. Needs to be of type unsigned integer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Shifted data in same shape as input.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift_data(array, val_old, val_new, dtype=np.int64):
    &#34;&#34;&#34;Shift integer array (data) from old to new values.

    &gt; **CAUTION:**
    &gt; The values of `val_old`, `val_new` and `data` needs to be integers.

    The basic function is based on Ashwini_Chaudhary solution:
    https://stackoverflow.com/a/29408060

    Parameters
    ----------
    array : StateTraj or ndarray or list or list of ndarrays
        1D data or a list of data.

    val_old : ndarray or list
        Values in data which should be replaced. All values needs to be within
        the range of `[data.min(), data.max()]`

    val_new : ndarray or list
        Values which will be used instead of old ones.

    dtype : data-type, optional
        The desired data-type. Needs to be of type unsigned integer.

    Returns
    -------
    array : ndarray
        Shifted data in same shape as input.

    &#34;&#34;&#34;
    # check data-type
    if not np.issubdtype(dtype, np.integer):
        raise TypeError(&#39;An unsigned integer type is needed.&#39;)

    # flatten data
    array, shape_kwargs = _flatten_data(array)

    # offset data and val_old to allow negative values
    offset = np.min([np.min(array), np.min(val_new)])

    # convert to np.array
    val_old = (np.asarray(val_old) - offset).astype(dtype)
    val_new = (np.asarray(val_new) - offset).astype(dtype)

    # convert data and shift
    array = (array - offset).astype(dtype)

    # shift data
    conv = np.arange(array.max() + 1, dtype=dtype)
    conv[val_old] = val_new
    array = conv[array]

    # shift data back
    array = array.astype(np.int32) + offset

    # reshape and return
    return _unflatten_data(array, shape_kwargs)</code></pre>
</details>
</dd>
<dt id="msmhelper.tools.swapcols"><code class="name flex">
<span>def <span class="ident">swapcols</span></span>(<span>array, indicesold, indicesnew)</span>
</code></dt>
<dd>
<div class="desc"><p>Interchange cols of an ndarray.</p>
<p>This method swaps the specified columns.</p>
<div class="admonition todo">
<p class="admonition-title">TODO</p>
<p>Optimize memory usage</p>
</div>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>array</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>2D numpy array.</dd>
<dt><strong><code>indicesold</code></strong> :&ensp;<code>integer</code> or <code>ndarray</code></dt>
<dd>1D array of indices.</dd>
<dt><strong><code>indicesnew</code></strong> :&ensp;<code>integer</code> or <code>ndarray</code></dt>
<dd>1D array of new indices</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>array_swapped</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>2D numpy array with swappend columns.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def swapcols(array, indicesold, indicesnew):
    r&#34;&#34;&#34;Interchange cols of an ndarray.

    This method swaps the specified columns.
    .. todo:: Optimize memory usage

    Parameters
    ----------
    array : ndarray
        2D numpy array.
    indicesold : integer or ndarray
        1D array of indices.
    indicesnew : integer or ndarray
        1D array of new indices

    Returns
    -------
    array_swapped : ndarray
        2D numpy array with swappend columns.

    &#34;&#34;&#34;
    # cast to 1d arrays
    indicesnew = _asindex(indicesnew)
    indicesold = _asindex(indicesold)

    if len(indicesnew) != len(indicesold):
        raise ValueError(&#39;Indices needs to be of same shape.&#39;)

    # cast data
    array = np.asarray(array)

    if np.all(indicesnew == indicesold):
        return array

    # fails for large data sets
    # noqa: E800 # array.T[indicesold] = array.T[indicesnew]
    array_swapped = np.copy(array)
    array_swapped.T[indicesold] = array.T[indicesnew]

    return array_swapped</code></pre>
</details>
</dd>
<dt id="msmhelper.tools.unique"><code class="name flex">
<span>def <span class="ident">unique</span></span>(<span>trajs, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply numpy.unique to traj.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>trajs</code></strong> :&ensp;<code>list</code> or <code>ndarray</code> or <code>list</code> of <code>ndarrays</code></dt>
<dd>State trajectory or list of state trajectories.</dd>
<dt><strong><code>kwargs</code></strong></dt>
<dd>Arguments of <a href="https://docs.scipy.org/doc/numpy/reference/generated.numpy.unique.html">numpy.unique()</a></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="msmhelper.tools.unique" href="#msmhelper.tools.unique">unique()</a></code></dt>
<dd>Array containing all states, see numpy for more details.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unique(trajs, **kwargs):
    r&#34;&#34;&#34;Apply numpy.unique to traj.

    Parameters
    ----------
    trajs : list or ndarray or list of ndarrays
        State trajectory or list of state trajectories.

    kwargs
        Arguments of [numpy.unique()](https://docs.scipy.org/doc/numpy/reference/generated.numpy.unique.html)

    Returns
    -------
    unique
        Array containing all states, see numpy for more details.

    &#34;&#34;&#34;
    # flatten data
    trajs, _ = _flatten_data(trajs)

    # get unique states with population
    return np.unique(trajs, **kwargs)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="msmhelper" href="index.html">msmhelper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="msmhelper.tools.find_first" href="#msmhelper.tools.find_first">find_first</a></code></li>
<li><code><a title="msmhelper.tools.format_state_traj" href="#msmhelper.tools.format_state_traj">format_state_traj</a></code></li>
<li><code><a title="msmhelper.tools.get_runtime_user_information" href="#msmhelper.tools.get_runtime_user_information">get_runtime_user_information</a></code></li>
<li><code><a title="msmhelper.tools.matrix_power" href="#msmhelper.tools.matrix_power">matrix_power</a></code></li>
<li><code><a title="msmhelper.tools.rename_by_index" href="#msmhelper.tools.rename_by_index">rename_by_index</a></code></li>
<li><code><a title="msmhelper.tools.rename_by_population" href="#msmhelper.tools.rename_by_population">rename_by_population</a></code></li>
<li><code><a title="msmhelper.tools.runningmean" href="#msmhelper.tools.runningmean">runningmean</a></code></li>
<li><code><a title="msmhelper.tools.shift_data" href="#msmhelper.tools.shift_data">shift_data</a></code></li>
<li><code><a title="msmhelper.tools.swapcols" href="#msmhelper.tools.swapcols">swapcols</a></code></li>
<li><code><a title="msmhelper.tools.unique" href="#msmhelper.tools.unique">unique</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://github.com/moldyn/msmhelper" class="github-corner" aria-label="View source on GitHub">
<svg width="80" height="80" viewBox="0 0 250 250" style="fill:#4d4f53; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true">
<path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
<path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
<path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path>
</svg>
</a>
<style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>